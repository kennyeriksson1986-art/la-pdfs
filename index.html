<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DKapp - LA & Tognummer</title>

    <!-- PWA / Standalone App Support -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="DKapp">
    <meta name="theme-color" content="#c41e3a">
    <link rel="icon" type="image/png" sizes="192x192" href="icon.png">
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="manifest" href="data:application/json,%7B%22name%22%3A%22DKapp%20-%20LA%20%26%20Tognummer%22%2C%22short_name%22%3A%22DKapp%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%23c41e3a%22%2C%22theme_color%22%3A%22%23c41e3a%22%2C%22orientation%22%3A%22portrait%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22icon.png%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image%2Fpng%22%7D%2C%7B%22src%22%3A%22icon.png%22%2C%22sizes%22%3A%22512x512%22%2C%22type%22%3A%22image%2Fpng%22%7D%5D%7D">
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        :root {
            --bg-primary: #f8fafc;
            --bg-card: #ffffff;
            --text-primary: #0f172a;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --accent: #0369a1;
            --accent-light: #e0f2fe;
            --accent-dark: #075985;
            --success: #059669;
            --success-light: #d1fae5;
            --train-accent: #0369a1;
            --train-accent-light: #e0f2fe;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        .dark {
            --bg-primary: #0f172a;
            --bg-card: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --accent: #38bdf8;
            --accent-light: #1e3a5f;
            --accent-dark: #0ea5e9;
            --success: #4ade80;
            --success-light: #14532d;
            --train-accent: #38bdf8;
            --train-accent-light: #1e3a5f;
            --border: #334155;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            padding: 8px;
            padding-top: 56px;
            overflow: hidden;
            background-image:
                radial-gradient(ellipse at 20% 20%, rgba(3, 105, 161, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(5, 150, 105, 0.08) 0%, transparent 50%);
        }

        .dark body, html.dark body {
            background-image:
                radial-gradient(ellipse at 20% 20%, rgba(56, 189, 248, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(74, 222, 128, 0.08) 0%, transparent 50%);
        }

        .container {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 12px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        .card.la-card {
            height: 50%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .card.train-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .card.train-card .results-card {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .top-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 44px;
            background: var(--bg-card);
            z-index: 1100;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            border-bottom: 1px solid var(--border);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .dark .top-header {
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .fullscreen-btn {
            width: 28px;
            height: 28px;
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin-right: 8px;
        }

        .fullscreen-btn:hover {
            background: var(--accent-light);
            color: var(--accent);
        }

        .fullscreen-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .card-header-icon {
            font-size: 1.2rem;
        }

        .card-header h2 {
            font-size: 0.95rem;
            font-weight: 700;
        }

        .header-clock {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            letter-spacing: 0.5px;
        }

        .header-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .refresh-btn {
            width: 28px;
            height: 28px;
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .refresh-btn:hover {
            background: var(--accent-light);
            color: var(--accent);
        }

        .refresh-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* LA Section Styles */
        .la-sections {
            display: flex;
            gap: 8px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden;
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }

        .section-header h3 {
            font-size: 0.75rem;
            font-weight: 600;
        }

        .section-content {
            flex: 1;
            overflow-y: auto;
        }

        .date-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: var(--accent-light);
            color: var(--accent);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            font-weight: 500;
        }

        .date-badge svg {
            width: 10px;
            height: 10px;
            fill: currentColor;
        }

        .downloads-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .download-item {
            display: flex;
            flex-direction: row;
            padding: 0;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .download-item-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .download-item-row {
            display: flex;
            align-items: stretch;
            width: 100%;
        }

        .download-item-clickable {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 8px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .download-item-clickable:hover {
            background: var(--accent-light);
        }

        .download-item-clickable.disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .download-item-clickable.disabled:hover {
            background: transparent;
        }

        .download-sidebar {
            width: 10%;
            min-width: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--success);
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .download-sidebar:hover {
            opacity: 0.85;
        }

        .download-sidebar.disabled {
            background: var(--border);
            cursor: not-allowed;
        }

        .download-sidebar svg {
            width: 16px;
            height: 16px;
            fill: white;
        }


        .route-name {
            font-weight: 700;
            font-size: 0.8rem;
        }

        .download-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-status {
            font-size: 0.65rem;
            color: var(--success);
            font-weight: 500;
        }

        .file-status.unavailable {
            color: var(--text-secondary);
        }

        .file-status.cached {
            color: var(--success);
            font-weight: 600;
        }

        .cache-btn {
            width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 1px solid var(--border);
        }

        .cache-btn:hover:not(.cached):not(.disabled) {
            background: var(--accent-light);
        }

        .cache-btn:hover:not(.cached):not(.disabled) svg {
            fill: var(--accent);
        }

        .cache-btn.cached {
            cursor: default;
            background: var(--success-light);
        }

        .cache-btn.cached svg {
            fill: var(--success);
        }

        .cache-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .cache-btn svg {
            width: 18px;
            height: 18px;
            fill: var(--text-secondary);
        }

        
        .rettelse-section {
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px dashed var(--border);
        }

        .rettelse-title {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 3px;
        }

        .rettelse-none {
            font-size: 0.6rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 3px 6px;
            text-align: center;
        }

        .rettelse-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: var(--bg-card);
            border-radius: 4px;
            margin-bottom: 3px;
        }

        .sync-status {
            font-size: 0.6rem;
            color: var(--text-secondary);
            padding: 3px 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            white-space: nowrap;
        }

        .sync-status.synced {
            color: var(--success);
            background: var(--success-light);
        }

        /* Half-screen PDF Overlay (top half, below header) */
        .pdf-overlay {
            position: fixed;
            top: 44px;
            left: 0;
            right: 0;
            height: calc(50vh - 22px);
            background: var(--bg-card);
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .pdf-overlay.active {
            display: flex;
        }

        .pdf-overlay.expanded {
            height: calc(100vh - 44px);
            z-index: 1050;
        }

        .pdf-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: var(--bg-card);
            color: var(--text-primary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .pdf-title {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .pdf-close-btn {
            width: 24px;
            height: 24px;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .pdf-close-btn:hover {
            background: var(--accent-light);
            color: var(--accent);
        }

        .pdf-actions {
            display: flex;
            gap: 4px;
        }

        .pdf-action-btn {
            width: 24px;
            height: 24px;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
        }

        .pdf-action-btn:hover {
            background: var(--accent-light);
            color: var(--accent);
        }

        .pdf-action-btn svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        .brightness-control {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-right: 8px;
        }

        .brightness-icon {
            font-size: 12px;
            opacity: 0.7;
        }

        .brightness-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border);
            border-radius: 2px;
            cursor: pointer;
        }

        .brightness-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .brightness-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .pdf-content {
            flex: 1;
            overflow-y: auto;
            background: #525659;
            padding: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .dark .pdf-content {
            background: #1e293b;
        }

        .pdf-content canvas {
            max-width: 100%;
            height: auto !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border-radius: 3px;
        }

        .pdf-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 30px;
            color: white;
        }

        /* Train Search Styles */
        .train-header {
            background: var(--bg-card);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .train-header.train-header-compact {
            padding: 6px 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .train-header.train-header-compact h2 {
            margin: 0;
            font-size: 0.8rem;
        }

        .train-header.train-header-compact .train-status-bar {
            margin: 0;
            padding: 3px 6px;
            font-size: 0.55rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
        }

        .test-reminder-btn {
            width: 28px;
            height: 28px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
        }

        .test-reminder-btn:hover {
            background: var(--accent-light);
        }

        .train-header h2 {
            font-size: 0.85rem;
            margin-bottom: 2px;
        }

        .train-status-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-top: 6px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.15);
            border-radius: 6px;
            font-size: 0.6rem;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #fbbf24;
            animation: pulse 1.5s infinite;
        }

        .status-dot.ready {
            background: #4ade80;
            animation: none;
        }

        .status-dot.error {
            background: #ef4444;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .search-section {
            display: flex;
            gap: 6px;
        }

        .search-wrapper {
            flex: 1;
            position: relative;
        }

        .search-icon {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            opacity: 0.5;
        }

        .search-input {
            width: 100%;
            padding: 8px 10px 8px 28px;
            font-size: 16px;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--train-accent);
        }

        .search-input:disabled {
            opacity: 0.5;
        }

        .search-btn {
            padding: 8px 14px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-btn:hover:not(:disabled) {
            background: var(--accent-light);
            color: var(--accent);
        }

        .search-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .results-card {
            margin-top: 10px;
        }

        .train-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
        }

        .variant-options {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .variant-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .variant-option:hover {
            border-color: var(--train-accent);
            background: var(--train-accent-light);
        }

        .variant-option.active {
            border-color: var(--train-accent);
            background: var(--train-accent-light);
        }

        .variant-number {
            width: 16px;
            height: 16px;
            background: var(--train-accent);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.55rem;
            margin-right: 6px;
            flex-shrink: 0;
        }

        .variant-left {
            display: flex;
            align-items: center;
        }

        .variant-info {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .variant-route {
            font-weight: 600;
            font-size: 0.65rem;
        }

        .variant-times {
            font-size: 0.55rem;
            color: var(--text-muted);
        }

        .variant-stops {
            font-size: 0.5rem;
            color: var(--text-secondary);
            background: var(--bg-card);
            padding: 2px 6px;
            border-radius: 6px;
        }

        .no-results {
            text-align: center;
            padding: 16px;
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        .initial-loading {
            text-align: center;
            padding: 12px;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        /* Half-screen Timetable Overlay (bottom half) */
        .timetable-overlay {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50vh;
            background: var(--bg-card);
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
        }

        .timetable-overlay.active {
            display: flex;
        }

        .timetable-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: var(--bg-card);
            color: var(--text-primary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .timetable-train {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.75rem;
        }

        .timetable-info {
            font-size: 0.55rem;
            opacity: 0.9;
            margin-left: auto;
        }

        .timetable-close-btn {
            width: 24px;
            height: 24px;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timetable-close-btn:hover {
            background: var(--train-accent-light);
            color: var(--train-accent);
        }

        .timetable-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            background: var(--bg-primary);
        }

        .timetable-meta {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 6px 8px;
            margin-bottom: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 0.55rem;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .timetable {
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border);
            font-family: 'JetBrains Mono', monospace;
        }

        .timetable-header-row {
            display: grid;
            grid-template-columns: 1fr 45px 50px 40px;
            gap: 4px;
            padding: 6px 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-weight: 700;
            font-size: 0.7rem;
            border-bottom: 1px solid var(--border);
        }

        .timetable-header-row span:not(:first-child) {
            text-align: center;
        }

        .timetable-row {
            display: grid;
            grid-template-columns: 1fr 45px 50px 40px;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            font-size: 0.65rem;
            align-items: center;
        }

        .timetable-row:last-child {
            border-bottom: none;
        }

        .timetable-row:nth-child(odd) {
            background: var(--bg-primary);
        }

        .station-name {
            font-weight: 500;
            font-size: 0.7rem;
        }

        .time-arr {
            text-align: center;
            color: var(--text-primary);
        }

        .time-dep {
            text-align: center;
            color: var(--text-primary);
            font-weight: 600;
        }

        .station-code {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.6rem;
        }

        @media (max-width: 400px) {
            .card {
                padding: 12px;
            }
        }

        /* Landscape mode - LA on left, Train on right */
        @media (orientation: landscape) and (min-width: 600px) {
            body {
                padding: 8px 12px;
                padding-top: 52px;
            }

            .container {
                max-width: 100%;
                flex-direction: row;
                gap: 12px;
            }

            .card.la-card {
                width: 50%;
                height: 100%;
                flex: 1;
            }

            .card.train-card {
                width: 50%;
                height: 100%;
                flex: 1;
            }

            .la-sections {
                flex-direction: row;
                gap: 8px;
            }

            .section {
                flex: 1;
                min-height: 0;
            }

            .section-content {
                flex: 1;
                overflow-y: auto;
            }

            .download-item {
                padding: 0;
            }

            .download-item-clickable {
                padding: 4px 6px;
            }

            .route-name {
                font-size: 0.7rem;
            }

            .file-name {
                font-size: 0.5rem;
            }

            .file-status {
                font-size: 0.55rem;
            }

            .cache-btn {
                min-width: 28px;
            }

            .pdf-overlay {
                left: 0;
                right: auto;
                width: 50%;
                height: calc(100vh - 44px);
            }

            .pdf-overlay.expanded {
                left: 0;
                right: 0;
                width: 100%;
            }

            .timetable-overlay {
                left: auto;
                right: 0;
                bottom: 0;
                width: 50%;
                height: calc(100vh - 44px);
            }
        }

        /* LA Reminder Modal */
        .la-reminder-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .la-reminder-content {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 16px;
            max-width: 280px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .la-reminder-text {
            font-size: 0.8rem;
            color: var(--text-primary);
            margin-bottom: 6px;
        }

        .la-reminder-question {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 14px;
        }

        .la-reminder-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .la-reminder-btn {
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .la-reminder-no {
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .la-reminder-no:hover {
            background: var(--border);
        }

        .la-reminder-yes {
            background: var(--accent);
            color: white;
        }

        .la-reminder-yes:hover {
            opacity: 0.9;
        }

        /* Info Tracker popup */
        .info-tracker-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
        }

        .info-tracker-content {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            max-width: 300px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }

        .info-tracker-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .info-tracker-text {
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .info-tracker-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .info-tracker-btn {
            padding: 12px 28px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .info-tracker-no {
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .info-tracker-no:hover {
            background: var(--border);
        }

        .info-tracker-yes {
            background: var(--success);
            color: white;
        }

        .info-tracker-yes:hover {
            opacity: 0.9;
        }

        /* Saved trains */
        .saved-trains-container {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 8px;
        }

        .saved-trains-container.hidden {
            display: none;
        }

        .saved-trains-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.7rem;
            font-weight: 600;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .clear-saved-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 2px 6px;
        }

        .clear-saved-btn:hover {
            color: var(--train-accent);
        }

        .saved-trains-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .saved-train-chip {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 4px 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .saved-train-chip:hover {
            border-color: var(--train-accent);
            background: var(--train-accent-light);
        }

        .saved-train-chip .remove-train {
            color: var(--text-muted);
            font-size: 0.65rem;
            margin-left: 2px;
        }

        .saved-train-chip .remove-train:hover {
            color: var(--train-accent);
        }

        .saved-train-chip.next-departure {
            border-color: var(--success);
            box-shadow: 0 0 0 1px var(--success);
        }

        .save-train-btn {
            width: 26px;
            height: 26px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .save-train-btn:hover:not(:disabled) {
            opacity: 0.85;
            transform: scale(1.05);
        }

        .save-train-btn.saved {
            background: var(--text-muted);
            cursor: default;
            font-size: 0.75rem;
        }

        .save-train-btn:disabled {
            opacity: 0.6;
        }

        .countdown-container {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--train-accent);
            color: white;
            padding: 3px 8px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            animation: pulse-glow 2s infinite;
            cursor: pointer;
        }

        .countdown-container.hidden {
            display: none;
        }

        .countdown-label {
            font-size: 0.55rem;
            opacity: 0.9;
        }

        .countdown-time {
            font-size: 0.75rem;
            font-weight: 700;
        }

        .countdown-container.urgent {
            background: #dc2626;
            animation: pulse-urgent 0.5s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(196, 30, 58, 0.4); }
            50% { box-shadow: 0 0 8px 2px rgba(196, 30, 58, 0.6); }
        }

        @keyframes pulse-urgent {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Password Screen */
        .password-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            background-image:
                radial-gradient(ellipse at 20% 20%, rgba(196, 30, 58, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(3, 105, 161, 0.1) 0%, transparent 50%);
        }

        .password-screen.hidden {
            display: none;
        }

        .password-box {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 32px;
            text-align: center;
            box-shadow: var(--shadow);
            max-width: 300px;
            width: 90%;
        }

        .password-icon {
            font-size: 3rem;
            margin-bottom: 8px;
        }

        .password-box h2 {
            font-size: 1.5rem;
            margin-bottom: 4px;
            color: var(--train-accent);
        }

        .password-box p {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .password-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 12px;
        }

        .password-input:focus {
            outline: none;
            border-color: var(--train-accent);
        }

        .password-btn {
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: var(--train-accent);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .password-btn:hover {
            opacity: 0.9;
        }

        .password-error {
            margin-top: 12px;
            color: #ef4444;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .password-error.hidden {
            display: none;
        }

        .login-version {
            display: block;
            margin-top: 16px;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .app-content {
            display: none;
        }

        .app-content.unlocked {
            display: block;
        }

        .version-label {
            font-size: 0.65rem;
            color: var(--text-secondary);
            opacity: 0.6;
            padding: 4px 6px;
        }
    </style>
</head>
<body>
    <!-- Password Screen -->
    <div class="password-screen" id="passwordScreen">
        <div class="password-box">
            <h2>DKapp</h2>
            <p>Ange lÃ¶senord fÃ¶r att fortsÃ¤tta</p>
            <input type="password" id="passwordInput" class="password-input" placeholder="LÃ¶senord" autofocus>
            <button class="password-btn" onclick="checkPassword()">Ã–ppna</button>
            <div class="password-error hidden" id="passwordError">Fel lÃ¶senord</div>
            <span class="login-version">v0.12</span>
        </div>
    </div>

    <!-- Fixed Top Header -->
    <div class="top-header">
        <h2 id="headerClock" class="header-clock">--:--:--</h2>
        <div class="header-right">
            <div class="sync-status" id="syncStatus">Kontrollerar...</div>
            <button class="fullscreen-btn" onclick="toggleFullscreen()" title="FullskÃ¤rm" id="fullscreenBtn">
                <svg viewBox="0 0 24 24" id="fullscreenIcon"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
            </button>
            <button class="refresh-btn" onclick="refreshLaDisplay()" title="Uppdatera">
                <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
            </button>
            <span class="version-label">v0.12</span>
        </div>
    </div>

    <div class="container">
        <!-- LA Section -->
        <div class="card la-card">
            <div class="la-sections">
                <div class="section">
                    <div class="section-header">
                        <h3 id="weekdayToday">Idag</h3>
                        <div class="date-badge" id="dateBadgeToday">
                            <span id="dateDisplayToday">...</span>
                        </div>
                    </div>
                    <div class="section-content" id="todayContent">
                        <div class="downloads-list" id="downloadsListToday"></div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-header">
                        <h3 id="weekdayTomorrow">I morgen</h3>
                        <div class="date-badge" id="dateBadgeTomorrow">
                            <span id="dateDisplayTomorrow">...</span>
                        </div>
                    </div>
                    <div class="section-content" id="tomorrowContent">
                        <div class="downloads-list" id="downloadsListTomorrow"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Train Search Section -->
        <div class="card train-card">
            <div class="search-section">
                <div class="search-wrapper">
                    <span class="search-icon">ðŸ”Ž</span>
                    <input type="text" class="search-input" id="searchInput" placeholder="HÃ¤mtar kÃ¶rplan..." disabled>
                </div>
                <button class="search-btn" id="searchBtn" disabled>SÃ¶k</button>
            </div>

            <div id="savedTrainsContainer" class="saved-trains-container hidden">
                <div id="savedTrainsList" class="saved-trains-list"></div>
            </div>

            <div class="results-card hidden" id="resultsCard">
                <div id="variantSelector"></div>
            </div>

        </div>
    </div>

    <!-- PDF Overlay (top half) -->
    <div class="pdf-overlay" id="pdfOverlay">
        <div class="pdf-header">
            <div class="pdf-title" id="pdfTitle">Laddar...</div>
            <div class="brightness-control">
                <span class="brightness-icon">ðŸ”†</span>
                <input type="range" class="brightness-slider" id="brightnessSlider" min="30" max="100" value="100" oninput="adjustBrightness(this.value)">
            </div>
            <div class="pdf-actions">
                <button class="pdf-action-btn" onclick="togglePdfExpand()" title="FÃ¶rstora/FÃ¶rminska" id="pdfExpandBtn">
                    <svg viewBox="0 0 24 24" id="pdfExpandIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zm.5-7H9v2H7v1h2v2h1v-2h2V9h-2z"/></svg>
                </button>
                <button class="pdf-action-btn" onclick="downloadCurrentPdf()" title="Ladda ner">
                    <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                </button>
                <a class="pdf-action-btn" id="pdfExternalLink" href="#" target="_blank" title="Ã–ppna i ny flik">
                    <svg viewBox="0 0 24 24"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/></svg>
                </a>
            </div>
            <button class="pdf-close-btn" onclick="closePdfOverlay()">âœ•</button>
        </div>
        <div class="pdf-content" id="pdfContent">
            <div class="pdf-loading">
                <div class="spinner"></div>
                <span>Laddar PDF...</span>
            </div>
        </div>
    </div>


    <!-- Timetable Overlay (bottom half) -->
    <div class="timetable-overlay" id="timetableOverlay">
        <div class="timetable-header">
            <div class="timetable-train" id="timetableTrain">Tog</div>
            <div class="countdown-container hidden" id="countdownContainer" onclick="hideCountdown()" title="Klicka fÃ¶r att dÃ¶lja">
                <span class="countdown-label">Ã˜sterport</span>
                <span class="countdown-time" id="countdownTime">--:--</span>
            </div>
            <div class="timetable-info" id="timetableInfo"></div>
            <button class="timetable-close-btn" onclick="closeTimetableOverlay()">âœ•</button>
        </div>
        <div class="timetable-content" id="timetableContent"></div>
    </div>

    <script>
        // ========================================
        // SHARED SETUP
        // ========================================

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // ========================================
        // SERVICE WORKER FOR OFFLINE SUPPORT
        // ========================================

        // Register Service Worker (requires sw.js file in same directory)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').then((reg) => {
                console.log('Service Worker registered for offline support');
            }).catch((err) => {
                console.log('Service Worker registration failed:', err);
            });
        }

        // Dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            document.documentElement.classList.toggle('dark', event.matches);
        });

        // Password protection
        const APP_PASSWORD = 'LaSr2025';
        const LOGIN_HOURS = 12;

        function setLoginCookie() {
            const expires = new Date();
            expires.setTime(expires.getTime() + (LOGIN_HOURS * 60 * 60 * 1000));
            document.cookie = `dkapp_auth=1; expires=${expires.toUTCString()}; path=/`;
        }

        function isLoggedIn() {
            return document.cookie.split(';').some(c => c.trim().startsWith('dkapp_auth='));
        }

        // Wake Lock to prevent screen from sleeping
        let wakeLock = null;

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock aktiverat');
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock slÃ¤ppt');
                    });
                }
            } catch (err) {
                console.log('Wake Lock misslyckades:', err.message);
            }
        }

        // Re-acquire wake lock when page becomes visible again
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && wakeLock === null) {
                await requestWakeLock();
            }
        });

        function checkPassword() {
            const input = document.getElementById('passwordInput');
            const error = document.getElementById('passwordError');

            if (input.value === APP_PASSWORD) {
                setLoginCookie();
                document.getElementById('passwordScreen').classList.add('hidden');
                // Try to enter fullscreen
                document.documentElement.requestFullscreen().catch(() => {});
                // Request wake lock to keep screen on
                requestWakeLock();
                initApp();
            } else {
                error.classList.remove('hidden');
                input.value = '';
                input.focus();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Check if already logged in
            if (isLoggedIn()) {
                document.getElementById('passwordScreen').classList.add('hidden');
                requestWakeLock();
                initApp();
            } else {
                const passwordInput = document.getElementById('passwordInput');
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        checkPassword();
                    }
                });
            }
        });

        // ========================================
        // LA SECTION
        // ========================================

        const LA_ROUTES = [
            { id: '10', name: 'StrÃ¦kning 10' },
            { id: '11', name: 'StrÃ¦kning 11' }
        ];

        const GITHUB_PAGES_URL = 'https://ke86.github.io/la-pdfs/';
        let availableFiles = [];
        let currentPdfUrl = '';
        let currentPdfFileName = '';
        let currentPdf = null;
        const downloadedFiles = new Set();
        const cachedFiles = new Set();
        let activeTrainNumber = null;

        // IndexedDB for reliable offline storage
        const DB_NAME = 'dkapp-offline';
        const DB_VERSION = 2;
        let db = null;

        async function initDB() {
            if (db) return db; // Already initialized
            if (!('indexedDB' in window)) {
                console.log('IndexedDB not supported');
                return null;
            }
            return new Promise((resolve, reject) => {
                try {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = () => {
                        console.log('IndexedDB open error:', request.error);
                        resolve(null);
                    };
                    request.onsuccess = () => {
                        db = request.result;
                        resolve(db);
                    };
                    request.onupgradeneeded = (event) => {
                        const database = event.target.result;
                        if (!database.objectStoreNames.contains('files')) {
                            database.createObjectStore('files', { keyPath: 'name' });
                        }
                        if (!database.objectStoreNames.contains('meta')) {
                            database.createObjectStore('meta', { keyPath: 'key' });
                        }
                        if (!database.objectStoreNames.contains('savedTrains')) {
                            database.createObjectStore('savedTrains', { keyPath: 'id' });
                        }
                    };
                } catch (e) {
                    console.log('IndexedDB exception:', e);
                    resolve(null);
                }
            });
        }

        async function saveToIDB(storeName, data) {
            if (!db) await initDB();
            if (!db) return; // Still no db
            return new Promise((resolve) => {
                try {
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    store.put(data);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => resolve();
                } catch (e) {
                    resolve();
                }
            });
        }

        async function getFromIDB(storeName, key) {
            if (!db) await initDB();
            if (!db) return null;
            return new Promise((resolve) => {
                try {
                    const tx = db.transaction(storeName, 'readonly');
                    const store = tx.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                } catch (e) {
                    resolve(null);
                }
            });
        }

        async function getAllFromIDB(storeName) {
            if (!db) await initDB();
            if (!db) return [];
            return new Promise((resolve) => {
                try {
                    const tx = db.transaction(storeName, 'readonly');
                    const store = tx.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => resolve([]);
                } catch (e) {
                    resolve([]);
                }
            });
        }

        async function deleteFromIDB(storeName, key) {
            if (!db) await initDB();
            if (!db) return;
            return new Promise((resolve) => {
                try {
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    store.delete(key);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => resolve();
                } catch (e) {
                    resolve();
                }
            });
        }

        // Track currently viewed train number
        let activeKbhDeparture = null; // Track departure time from KÃ¸benhavn H
        let activeOsterportDeparture = null; // Track departure time from Ã˜sterport
        let activePeberholmDeparture = null; // Track departure time from Peberholm
        let laReminderShown = false; // Track if reminder has been shown
        let infoTrackerShown = false; // Track if Info tracker popup has been shown
        let laReminderInterval = null; // Interval for checking time
        let countdownInterval = null; // Interval for countdown timer
        let infoTrackerInterval = null; // Interval for Info tracker check

        // Save/restore open view state (expires after 1 hour)
        const VIEW_STATE_EXPIRY_MS = 60 * 60 * 1000; // 1 hour

        async function saveViewState() {
            const state = {
                key: 'viewState',
                timestamp: Date.now(),
                pdf: currentPdfUrl ? { url: currentPdfUrl, fileName: currentPdfFileName } : null,
                train: activeTrainNumber ? {
                    trainNum: String(activeTrainNumber),
                    variantIndex: activeVariantIndex,
                    variant: currentVariants[activeVariantIndex] || null
                } : null
            };
            await saveToIDB('meta', state);
        }

        async function restoreViewState() {
            const state = await getFromIDB('meta', 'viewState');
            if (!state) return;

            // Check if state has expired (older than 1 hour)
            if (state.timestamp && (Date.now() - state.timestamp) > VIEW_STATE_EXPIRY_MS) {
                console.log('View state expired, clearing');
                await clearViewState();
                return;
            }

            // Restore PDF overlay
            if (state.pdf && state.pdf.url) {
                // Small delay to let the app initialize
                setTimeout(() => {
                    openPdfOverlay(state.pdf.url, state.pdf.fileName);
                }, 300);
            }

            // Restore timetable overlay
            if (state.train && state.train.variant) {
                setTimeout(() => {
                    currentVariants = [state.train.variant];
                    currentTrainQuery = state.train.trainNum;
                    activeVariantIndex = 0;
                    searchInput.value = state.train.trainNum;
                    showVariantSelector(currentVariants, state.train.trainNum);
                    openTimetableOverlay(state.train.variant, state.train.trainNum);
                    resultsCard.classList.remove('hidden');
                }, 100);
            }
        }

        async function clearViewState() {
            await saveToIDB('meta', { key: 'viewState', pdf: null, train: null, timestamp: null });
        }

        async function fetchWithTimeout(url, timeout = 3000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                return response;
            } catch (e) {
                clearTimeout(timeoutId);
                throw e;
            }
        }

        async function fetchAvailableFiles() {
            const indexUrl = GITHUB_PAGES_URL + 'index.json';

            // ALWAYS load from cache/IDB first for instant display
            await loadFromCache(indexUrl);

            // If we have cached data, mark as success for offline
            const hasCachedData = availableFiles.length > 0;
            if (hasCachedData) {
                console.log('Har cachad data:', availableFiles.length, 'filer');
            }

            // If offline, don't try network at all
            if (!navigator.onLine) {
                console.log('Offline-lÃ¤ge, anvÃ¤nder endast cache');
                return hasCachedData;
            }

            // Online: Try network with SHORT timeout (3 sec)
            try {
                const response = await fetchWithTimeout(indexUrl + '?t=' + Date.now(), 3000);
                if (response.ok) {
                    availableFiles = await response.json();
                    // Cache for offline
                    if ('caches' in window) {
                        const cache = await caches.open('dkapp-v2');
                        const cacheResponse = new Response(JSON.stringify(availableFiles), {
                            headers: { 'Content-Type': 'application/json' }
                        });
                        await cache.put(indexUrl, cacheResponse);
                    }
                    // Also save to IndexedDB
                    try {
                        await saveToIDB('meta', { key: 'availableFiles', data: availableFiles });
                    } catch (e) {}
                    return true;
                }
            } catch (e) {
                console.log('NÃ¤tverksfel (timeout 3s):', e.message);
            }

            return hasCachedData;
        }

        async function loadFromCache(indexUrl) {
            // Try Cache API first
            if ('caches' in window) {
                try {
                    const cache = await caches.open('dkapp-v2');
                    const cachedResponse = await cache.match(indexUrl);
                    if (cachedResponse) {
                        availableFiles = await cachedResponse.json();
                        console.log('Laddat index.json frÃ¥n Cache API:', availableFiles.length, 'filer');
                        return true;
                    }
                } catch (e) {
                    console.log('Cache API-fel:', e.message);
                }
            }

            // Try IndexedDB as backup
            try {
                await initDB();
                const meta = await getFromIDB('meta', 'availableFiles');
                if (meta && meta.data && meta.data.length > 0) {
                    availableFiles = meta.data;
                    console.log('Laddat index.json frÃ¥n IndexedDB:', availableFiles.length, 'filer');
                    return true;
                }
            } catch (e) {
                console.log('IndexedDB-fel:', e.message);
            }

            // Check for any cached PDF files in IDB
            try {
                const files = await getAllFromIDB('files');
                if (files && files.length > 0) {
                    availableFiles = files.map(f => f.name);
                    console.log('Hittade PDF-filer i IndexedDB:', files.length);
                    return true;
                }
            } catch (e) {}

            availableFiles = [];
            return false;
        }

        async function checkCachedFiles() {
            // Check Cache API
            if ('caches' in window) {
                try {
                    const cache = await caches.open('dkapp-v2');
                    const keys = await cache.keys();
                    keys.forEach(req => {
                        const url = req.url;
                        // Check against availableFiles
                        availableFiles.forEach(fileName => {
                            if (url.includes(fileName)) {
                                cachedFiles.add(fileName);
                            }
                        });
                        // Also extract filename from URL and add to cachedFiles
                        const match = url.match(/La-\d+-\d{4}-\d{2}-\d{2}-\d{4}-\d{2}-\d{2}(-R\d+)?\.pdf/);
                        if (match) {
                            cachedFiles.add(match[0]);
                            // Also add to availableFiles if not there
                            if (!availableFiles.includes(match[0])) {
                                availableFiles.push(match[0]);
                            }
                        }
                    });
                } catch (e) {
                    console.log('Cache API error:', e);
                }
            }

            // Also check IndexedDB
            try {
                await initDB();
                const files = await getAllFromIDB('files');
                files.forEach(file => {
                    cachedFiles.add(file.name);
                    if (!availableFiles.includes(file.name)) {
                        availableFiles.push(file.name);
                    }
                });
                console.log('IndexedDB files:', files.length);
            } catch (e) {
                console.log('IndexedDB check error:', e);
            }
        }

        async function cacheFileForOffline(url, fileName, event) {
            if (event) event.stopPropagation();
            if (cachedFiles.has(fileName)) return;

            try {
                const response = await fetch(url);
                if (response.ok) {
                    // Save to Cache API
                    if ('caches' in window) {
                        const cache = await caches.open('dkapp-v2');
                        await cache.put(url, response.clone());
                    }

                    // Also save PDF data to IndexedDB (more reliable on Android)
                    try {
                        const blob = await response.clone().blob();
                        const reader = new FileReader();
                        reader.onload = async () => {
                            await saveToIDB('files', {
                                name: fileName,
                                url: url,
                                data: reader.result,
                                timestamp: Date.now()
                            });
                        };
                        reader.readAsDataURL(blob);
                    } catch (e) {
                        console.log('IDB save error:', e);
                    }

                    cachedFiles.add(fileName);
                    // Update UI
                    const today = getDateSwedish(0);
                    const tomorrow = getDateSwedish(1);
                    await updateCacheStatus('today', today);
                    await updateCacheStatus('tomorrow', tomorrow);
                }
            } catch (e) {
                console.log('Cache error:', e);
            }
        }

        async function updateCacheStatus(dayKey, date) {
            for (const route of LA_ROUTES) {
                const fileName = getFileName(route.id, date);
                const cacheBtn = document.getElementById(`cache-${dayKey}-${route.id}`);
                if (cacheBtn && cachedFiles.has(fileName)) {
                    cacheBtn.classList.add('cached');
                    cacheBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';
                    cacheBtn.onclick = null;
                }
            }
        }

        function isFileAvailable(fileName) {
            return availableFiles.includes(fileName);
        }

        function isTomorrowUnlocked() {
            // Tomorrow's LA is available after 18:00 Copenhagen time
            const now = new Date();
            const copenhagenHour = parseInt(new Intl.DateTimeFormat('en-US', {
                timeZone: 'Europe/Copenhagen',
                hour: 'numeric',
                hour12: false
            }).format(now));
            return copenhagenHour >= 18;
        }

        function getDateSwedish(daysOffset = 0) {
            const now = new Date();
            now.setDate(now.getDate() + daysOffset);
            return new Intl.DateTimeFormat('sv-SE', {
                timeZone: 'Europe/Copenhagen',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            }).format(now);
        }

        function getSwedishWeekday(daysOffset = 0) {
            const now = new Date();
            now.setDate(now.getDate() + daysOffset);
            const weekday = new Intl.DateTimeFormat('sv-SE', {
                timeZone: 'Europe/Copenhagen',
                weekday: 'long'
            }).format(now);
            return weekday.charAt(0).toUpperCase() + weekday.slice(1);
        }

        function getFileName(routeId, date) {
            return `La-${routeId}-${date}-${date}.pdf`;
        }

        function getFullUrl(fileName) {
            return GITHUB_PAGES_URL + fileName;
        }

        function getRettelseFileName(routeId, date, rNumber) {
            return `La-${routeId}-${date}-${date}-R${rNumber}.pdf`;
        }

        async function checkFileIsPdf(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) return false;
                const reader = response.body.getReader();
                const { value } = await reader.read();
                reader.cancel();
                if (!value || value.length < 5) return false;
                const header = String.fromCharCode(value[0], value[1], value[2], value[3], value[4]);
                return header === '%PDF-';
            } catch (e) {
                return false;
            }
        }

        async function findRettelser(date) {
            const checkPromises = [];
            for (const route of LA_ROUTES) {
                for (let r = 1; r <= 10; r++) {
                    const fileName = getRettelseFileName(route.id, date, r);
                    if (isFileAvailable(fileName)) {
                        const url = getFullUrl(fileName);
                        checkPromises.push(
                            checkFileIsPdf(url).then(isPdf => isPdf ? { fileName, url, rNumber: r, routeId: route.id } : null)
                        );
                    }
                }
            }
            const results = await Promise.all(checkPromises);
            return results.filter(r => r !== null).sort((a, b) => {
                if (a.routeId !== b.routeId) return a.routeId.localeCompare(b.routeId);
                return a.rNumber - b.rNumber;
            });
        }

        function renderDownloadItems(containerId, date, dayKey, rettelser) {
            const container = document.getElementById(containerId);
            container.innerHTML = LA_ROUTES.map(route => {
                const fileName = getFileName(route.id, date);
                const url = getFullUrl(fileName);
                let isAvailable = isFileAvailable(fileName);
                const isDownloaded = downloadedFiles.has(`${dayKey}-${route.id}`);
                const isCached = cachedFiles.has(fileName);

                // Tomorrow's files are locked until 16:00
                const isTomorrowLocked = dayKey === 'tomorrow' && !isTomorrowUnlocked();
                if (isTomorrowLocked && !isCached) {
                    isAvailable = false;
                }

                const routeRettelser = rettelser.filter(r => r.routeId === route.id);
                const rettelseHtml = renderRettelseHtml(routeRettelser, dayKey);

                const shortFileName = fileName.length > 16 ? fileName.substring(0, 16) + '...' : fileName;
                const statusText = isCached ? 'âœ“ Sparad offline' : (isTomorrowLocked ? 'Kommer kl 18:00' : (isAvailable ? 'âœ“ TillgÃ¤nglig' : 'Kommer senare'));
                const statusClass = isCached ? 'cached' : (isAvailable ? '' : 'unavailable');

                return `
                <div class="download-item" id="item-${dayKey}-${route.id}">
                    <div class="download-item-content">
                        <div class="download-item-row">
                            <div class="download-item-clickable ${isAvailable || isCached ? '' : 'disabled'}" onclick="${isAvailable || isCached ? `openPdfOverlay('${url}', '${fileName}')` : ''}">
                                <div class="route-name">${route.name}</div>
                                <div class="file-name">${shortFileName}</div>
                                <div class="file-status ${statusClass}">${statusText}</div>
                            </div>
                        </div>
                        ${rettelseHtml}
                    </div>
                    <div class="cache-btn ${isCached ? 'cached' : ''} ${isAvailable ? '' : 'disabled'}" id="cache-${dayKey}-${route.id}" onclick="${isAvailable && !isCached ? `cacheFileForOffline('${url}', '${fileName}', event)` : ''}" title="${isCached ? 'Sparad offline' : 'Spara fÃ¶r offline'}">
                        <svg viewBox="0 0 24 24"><path d="${isCached ? 'M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z' : 'M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z'}"/></svg>
                    </div>
                </div>`;
            }).join('');
        }

        function renderRettelseHtml(rettelser, dayKey) {
            if (rettelser.length === 0) {
                return `<div class="rettelse-section"><div class="rettelse-none">Ingen rettelse</div></div>`;
            }
            const items = rettelser.map(r => `
                <div class="rettelse-item" style="display:flex;align-items:stretch;padding:0;overflow:hidden;border-radius:4px;border:1px solid var(--border);margin-bottom:3px;">
                    <div style="flex:1;padding:4px 8px;cursor:pointer;" onclick="openPdfOverlay('${r.url}', '${r.fileName}')">
                        <div class="file-name">${r.fileName}</div>
                    </div>
                </div>
            `).join('');
            return `<div class="rettelse-section"><div class="rettelse-title">Rettelse til La</div>${items}</div>`;
        }

        async function refreshLaDisplay() {
            const syncStatus = document.getElementById('syncStatus');
            syncStatus.textContent = 'Laddar...';
            syncStatus.classList.remove('synced');

            try {
                // Initialize IndexedDB first
                await initDB();
            } catch (e) {
                console.log('IndexedDB init error:', e);
            }

            let success = false;
            try {
                success = await fetchAvailableFiles();
            } catch (e) {
                console.log('fetchAvailableFiles error:', e);
            }

            try {
                await checkCachedFiles();
            } catch (e) {
                console.log('checkCachedFiles error:', e);
            }

            const today = getDateSwedish(0);
            const tomorrow = getDateSwedish(1);

            document.getElementById('weekdayToday').textContent = getSwedishWeekday(0);
            document.getElementById('weekdayTomorrow').textContent = getSwedishWeekday(1);
            document.getElementById('dateDisplayToday').textContent = today;
            document.getElementById('dateDisplayTomorrow').textContent = tomorrow;

            renderDownloadItems('downloadsListToday', today, 'today', []);
            renderDownloadItems('downloadsListTomorrow', tomorrow, 'tomorrow', []);

            const [rettelserToday, rettelserTomorrow] = await Promise.all([
                findRettelser(today),
                findRettelser(tomorrow)
            ]);

            renderDownloadItems('downloadsListToday', today, 'today', rettelserToday);
            renderDownloadItems('downloadsListTomorrow', tomorrow, 'tomorrow', rettelserTomorrow);

            // Update status based on what we have
            // Only count main LA files (not rettelser) for today and tomorrow
            const isOffline = !navigator.onLine;
            const mainLaCount = Array.from(cachedFiles).filter(f => {
                // Only count if it's a main LA file (no -R in filename) and is for today or tomorrow
                if (f.includes('-R')) return false;
                const match = f.match(/La-\d+-(\d{4}-\d{2}-\d{2})/);
                if (!match) return false;
                const fileDate = match[1];
                return fileDate === today || fileDate === tomorrow;
            }).length;

            if (mainLaCount > 0) {
                syncStatus.textContent = isOffline ? `ðŸ“´ ${mainLaCount} LA offline` : `âœ“ ${mainLaCount} LA sparade`;
                syncStatus.classList.add('synced');
            } else if (cachedFiles.size > 0) {
                syncStatus.textContent = isOffline ? `ðŸ“´ Offline` : `âœ“ Synkad`;
                syncStatus.classList.add('synced');
            } else if (isOffline) {
                syncStatus.textContent = 'ðŸ“´ Offline';
            } else {
                syncStatus.textContent = 'VÃ¤ntar pÃ¥ data...';
            }
            console.log('Status:', { isOffline, mainLaCount, cachedFiles: cachedFiles.size });
        }

        async function downloadPdf(url, fileName, dayKey, routeId, event) {
            if (event) event.preventDefault();
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                link.click();
                if (dayKey && routeId) {
                    downloadedFiles.add(`${dayKey}-${routeId}`);
                    const btn = document.getElementById(`dlbtn-${dayKey}-${routeId}`);
                    if (btn) {
                        btn.classList.add('downloaded');
                        btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';
                        btn.onclick = null;
                    }
                }
            } catch (e) {
                window.open(url, '_blank');
            }
        }

        function downloadCurrentPdf() {
            if (currentPdfUrl && currentPdfFileName) {
                downloadPdf(currentPdfUrl, currentPdfFileName);
            }
        }

        async function openPdfOverlay(url, fileName) {
            currentPdfUrl = url;
            currentPdfFileName = fileName;

            const overlay = document.getElementById('pdfOverlay');
            const content = document.getElementById('pdfContent');
            document.getElementById('pdfTitle').textContent = fileName;
            document.getElementById('pdfExternalLink').href = url;

            content.innerHTML = '<div class="pdf-loading"><div class="spinner"></div><span>Laddar PDF...</span></div>';
            overlay.classList.add('active');

            // Save view state for restoration on app restart
            saveViewState();

            try {
                let pdfData = url;

                // If offline, try to get PDF from IndexedDB first
                if (!navigator.onLine) {
                    try {
                        const cachedFile = await getFromIDB('files', fileName);
                        if (cachedFile && cachedFile.data) {
                            console.log('Laddar PDF frÃ¥n IndexedDB:', fileName);
                            pdfData = cachedFile.data;
                        }
                    } catch (e) {
                        console.log('IDB hÃ¤mtning misslyckades:', e);
                    }
                }

                currentPdf = await pdfjsLib.getDocument(pdfData).promise;
                const totalPages = currentPdf.numPages;
                content.innerHTML = '';

                const containerWidth = content.clientWidth - 12;
                const pixelRatio = window.devicePixelRatio || 2;

                // Determine which page to scroll to based on active train number and StrÃ¦kning
                let scrollToPage = 1;
                if (activeTrainNumber !== null) {
                    const isEven = activeTrainNumber % 2 === 0;
                    // Check which StrÃ¦kning this is based on filename
                    const isStraekning11 = fileName.includes('La-11');
                    const isStraekning10 = fileName.includes('La-10');

                    if (isStraekning11) {
                        // StrÃ¦kning 11: Even -> page 1, Odd -> page 2
                        scrollToPage = isEven ? 1 : 2;
                    } else if (isStraekning10) {
                        // StrÃ¦kning 10: Even -> page 2, Odd -> page 1
                        scrollToPage = isEven ? 2 : 1;
                    }
                }

                for (let i = 1; i <= totalPages; i++) {
                    const page = await currentPdf.getPage(i);
                    const viewport = page.getViewport({ scale: 1 });
                    const scale = containerWidth / viewport.width;
                    const scaledViewport = page.getViewport({ scale: scale * pixelRatio });

                    const canvas = document.createElement('canvas');
                    canvas.width = scaledViewport.width;
                    canvas.height = scaledViewport.height;
                    canvas.style.width = (scaledViewport.width / pixelRatio) + 'px';
                    canvas.style.height = (scaledViewport.height / pixelRatio) + 'px';
                    if (i === scrollToPage) {
                        canvas.id = 'scrollTarget';
                    }
                    content.appendChild(canvas);

                    await page.render({ canvasContext: canvas.getContext('2d'), viewport: scaledViewport }).promise;
                }

                // Scroll to the target page if needed
                if (scrollToPage > 1 && totalPages >= scrollToPage) {
                    const targetCanvas = document.getElementById('scrollTarget');
                    if (targetCanvas) {
                        targetCanvas.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }
            } catch (error) {
                content.innerHTML = `<div class="pdf-loading"><p>Kunde inte ladda PDF</p><a href="${url}" target="_blank" style="color:#38bdf8;">Ã–ppna i ny flik</a></div>`;
            }
        }

        function closePdfOverlay() {
            const overlay = document.getElementById('pdfOverlay');
            overlay.classList.remove('active');
            overlay.classList.remove('expanded');
            currentPdf = null;
            currentPdfUrl = '';
            currentPdfFileName = '';
            // Reset brightness
            document.getElementById('brightnessSlider').value = 100;
            document.getElementById('pdfContent').style.filter = 'brightness(1)';
            // Reset expand icon
            document.getElementById('pdfExpandIcon').innerHTML = '<path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zm.5-7H9v2H7v1h2v2h1v-2h2V9h-2z"/>';
            // Update saved view state
            saveViewState();
        }

        function adjustBrightness(value) {
            const brightness = value / 100;
            document.getElementById('pdfContent').style.filter = `brightness(${brightness})`;
        }

        function togglePdfExpand() {
            const overlay = document.getElementById('pdfOverlay');
            const icon = document.getElementById('pdfExpandIcon');
            const isExpanded = overlay.classList.toggle('expanded');

            if (isExpanded) {
                // Minimize icon (zoom out)
                icon.innerHTML = '<path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z"/>';
            } else {
                // Expand icon (zoom in)
                icon.innerHTML = '<path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zm.5-7H9v2H7v1h2v2h1v-2h2V9h-2z"/>';
            }
        }

        // ========================================
        // TRAIN SEARCH SECTION
        // ========================================

        const TRAIN_PDF_URL = 'https://pfst.cf2.poecdn.net/base/application/81be3980309992dbd2a57c597ec8b1bdc0c7af1de350549f7e0b24c2db30a231';
        let pdfLines = [];
        let currentVariants = [];
        let currentTrainQuery = '';
        let activeVariantIndex = -1;

        const searchInput = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');
        const resultsCard = document.getElementById('resultsCard');
        const variantSelector = document.getElementById('variantSelector');
        const savedTrainsContainer = document.getElementById('savedTrainsContainer');
        const savedTrainsList = document.getElementById('savedTrainsList');

        // Saved trains (max 10) - stores objects with trainNum, variantIndex, and route
        let savedTrains = [];

        function getSavedTrainsCookie() {
            const match = document.cookie.match(/dkapp_trains=([^;]*)/);
            if (match) {
                try {
                    return JSON.parse(decodeURIComponent(match[1]));
                } catch (e) {
                    return [];
                }
            }
            return [];
        }

        function setSavedTrainsCookie() {
            const expires = new Date();
            expires.setTime(expires.getTime() + (30 * 24 * 60 * 60 * 1000)); // 30 days
            document.cookie = `dkapp_trains=${encodeURIComponent(JSON.stringify(savedTrains))}; expires=${expires.toUTCString()}; path=/`;
        }

        function loadSavedTrains() {
            savedTrains = getSavedTrainsCookie();
            renderSavedTrains();
        }

        function renderSavedTrains() {
            if (savedTrains.length === 0) {
                savedTrainsContainer.classList.add('hidden');
                return;
            }

            // Find the train with the closest upcoming departure
            const now = new Date();
            const currentMinutes = now.getHours() * 60 + now.getMinutes();
            let closestIdx = -1;
            let closestDiff = Infinity;

            savedTrains.forEach((train, idx) => {
                if (train.departureTime) {
                    const parts = train.departureTime.split(':');
                    if (parts.length === 2) {
                        const depMinutes = parseInt(parts[0]) * 60 + parseInt(parts[1]);
                        const diff = depMinutes - currentMinutes;
                        // Only consider future departures (diff > 0), or within 5 min passed
                        if (diff > -5 && diff < closestDiff) {
                            closestDiff = diff;
                            closestIdx = idx;
                        }
                    }
                }
            });

            savedTrainsContainer.classList.remove('hidden');
            savedTrainsList.innerHTML = savedTrains.map((train, idx) => {
                const isClosest = idx === closestIdx;
                return `
                <div class="saved-train-chip ${isClosest ? 'next-departure' : ''}" onclick="searchSavedTrain('${train.trainNum}', ${train.variantIndex})">
                    <span>${train.trainNum}</span>
                    <span class="remove-train" onclick="removeSavedTrain(${idx}, event)" title="Ta bort">âœ•</span>
                </div>
            `}).join('');
        }

        async function saveTrain(trainNum, variantIndex, route, departureTime, variantData) {
            if (!trainNum) return;

            // Create unique key for this variant
            const key = `${trainNum}-${variantIndex}`;

            // Check if already saved (same train + variant)
            if (savedTrains.some(t => `${t.trainNum}-${t.variantIndex}` === key)) {
                return;
            }

            // Check max limit
            if (savedTrains.length >= 10) {
                // Remove oldest and its cached data
                const removed = savedTrains.shift();
                if (removed) {
                    await deleteFromIDB('savedTrains', `${removed.trainNum}-${removed.variantIndex}`);
                }
            }

            savedTrains.push({ trainNum, variantIndex, route, departureTime: departureTime || '' });
            setSavedTrainsCookie();

            // Save full variant data to IndexedDB for offline access
            if (variantData) {
                await saveToIDB('savedTrains', {
                    id: key,
                    trainNum,
                    variantIndex,
                    variant: variantData
                });
            }

            renderSavedTrains();
            // Re-render variants to update button states
            if (currentVariants.length > 0) {
                showVariantSelector(currentVariants, currentTrainQuery);
            }
        }

        function isTrainVariantSaved(trainNum, variantIndex) {
            return savedTrains.some(t => t.trainNum === trainNum && t.variantIndex === variantIndex);
        }

        async function removeSavedTrain(index, event) {
            event.stopPropagation(); // Prevent triggering search
            const train = savedTrains[index];
            if (train) {
                await deleteFromIDB('savedTrains', `${train.trainNum}-${train.variantIndex}`);
            }
            savedTrains.splice(index, 1);
            setSavedTrainsCookie();
            renderSavedTrains();
            // Re-render variants to update button states
            if (currentVariants.length > 0) {
                showVariantSelector(currentVariants, currentTrainQuery);
            }
        }

        async function clearSavedTrains() {
            // Delete all cached train data
            for (const train of savedTrains) {
                await deleteFromIDB('savedTrains', `${train.trainNum}-${train.variantIndex}`);
            }
            savedTrains = [];
            setSavedTrainsCookie();
            renderSavedTrains();
            // Re-render variants to update button states
            if (currentVariants.length > 0) {
                showVariantSelector(currentVariants, currentTrainQuery);
            }
        }

        async function searchSavedTrain(trainNum, variantIndex) {
            searchInput.value = trainNum;

            // Try to load cached variant data first
            const key = `${trainNum}-${variantIndex}`;
            const cached = await getFromIDB('savedTrains', key);

            if (cached && cached.variant) {
                // Show cached data immediately
                currentVariants = [cached.variant];
                currentTrainQuery = trainNum;
                activeVariantIndex = 0;
                showVariantSelector(currentVariants, trainNum);
                openTimetableOverlay(cached.variant, trainNum);
                resultsCard.classList.remove('hidden');
            } else {
                // Fall back to searching
                searchForTrain(trainNum, true, variantIndex);
            }
        }

        async function loadTrainPDF() {
            try {
                searchInput.placeholder = 'HÃ¤mtar kÃ¶rplan...';
                const response = await fetch(TRAIN_PDF_URL);
                const arrayBuffer = await response.arrayBuffer();
                searchInput.placeholder = 'Analyserar kÃ¶rplan...';

                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let text = '';

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    const items = content.items;
                    let currentY = null;
                    let currentLine = [];
                    const lines = [];

                    items.forEach(item => {
                        const y = Math.round(item.transform[5]);
                        if (currentY === null || Math.abs(y - currentY) < 5) {
                            currentLine.push({ text: item.str, x: item.transform[4] });
                            currentY = y;
                        } else {
                            if (currentLine.length > 0) {
                                currentLine.sort((a, b) => a.x - b.x);
                                lines.push(currentLine.map(l => l.text).join(' '));
                            }
                            currentLine = [{ text: item.str, x: item.transform[4] }];
                            currentY = y;
                        }
                    });

                    if (currentLine.length > 0) {
                        currentLine.sort((a, b) => a.x - b.x);
                        lines.push(currentLine.map(l => l.text).join(' '));
                    }
                    text += lines.join('\n') + '\n';
                }

                pdfLines = text.split('\n');
                searchInput.disabled = false;
                searchBtn.disabled = false;
                searchInput.placeholder = 'K26, SÃ¶k tÃ¥gnummer';

            } catch (error) {
                searchInput.placeholder = 'Fel vid laddning';
            }
        }

        searchBtn.addEventListener('click', () => {
            const query = searchInput.value.trim();
            if (query) searchForTrain(query);
        });

        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = searchInput.value.trim();
                if (query) searchForTrain(query);
            }
        });

        function searchForTrain(query, autoOpen = false, specificVariant = 0) {
            // Close any open timetable
            closeTimetableOverlay();
            activeVariantIndex = -1;

            resultsCard.classList.remove('hidden');
            currentTrainQuery = query;

            variantSelector.innerHTML = '<div class="initial-loading"><div class="spinner"></div><p>SÃ¸ger...</p></div>';

            setTimeout(() => {
                const variants = extractAllVariants(query);
                currentVariants = variants;

                if (variants.length === 0) {
                    variantSelector.innerHTML = '<div class="no-results">ðŸ” Ingen kÃ¸replan fundet</div>';
                } else {
                    showVariantSelector(variants, query);
                    // Auto-open specific variant if requested (e.g., from saved trains)
                    if (autoOpen && variants.length > 0) {
                        const variantToOpen = Math.min(specificVariant, variants.length - 1);
                        activeVariantIndex = variantToOpen;
                        const variantOptions = variantSelector.querySelectorAll('.variant-option');
                        if (variantOptions[variantToOpen]) {
                            variantOptions[variantToOpen].classList.add('active');
                        }
                        openTimetableOverlay(variants[variantToOpen], query);
                    }
                }
            }, 100);
        }

        function extractAllVariants(trainNum) {
            const headerRegex = new RegExp(`Ã˜P\\s*${trainNum}\\b`, 'i');
            const headerLines = [];

            pdfLines.forEach((line, index) => {
                if (headerRegex.test(line) && !line.includes('Ank') && !line.includes('Afg')) {
                    headerLines.push(index);
                }
            });

            if (headerLines.length === 0) return [];

            const variants = [];
            headerLines.forEach((startLine, groupIndex) => {
                const metadata = extractTrainMetadata(trainNum, startLine);
                const stops = extractTimetableForGroup(trainNum, startLine);

                if (stops.length > 0) {
                    variants.push({
                        id: groupIndex,
                        stops,
                        firstStation: stops[0].station,
                        lastStation: stops[stops.length - 1].station,
                        firstTime: stops[0].departure !== '-' ? stops[0].departure : stops[0].arrival,
                        lastTime: stops[stops.length - 1].arrival !== '-' ? stops[stops.length - 1].arrival : stops[stops.length - 1].departure,
                        stopCount: stops.length,
                        ...metadata
                    });
                }
            });

            const seen = new Set();
            return variants.filter(v => {
                const key = v.route ? `${v.route}-${v.schedule}` : `${v.firstStation}-${v.lastStation}-${v.stopCount}`;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        function extractTrainMetadata(trainNum, startLine) {
            let route = '', schedule = '', togart = '', hast = '';

            // Combine lines to search through
            let combinedText = '';
            for (let i = startLine; i < Math.min(pdfLines.length, startLine + 25); i++) {
                const line = pdfLines[i].trim();
                if (line.includes('Ank') && line.includes('Afg')) break;
                combinedText += ' ' + line;

                // Look for route like "Ã˜sterport - MalmÃ¸ Central"
                if (!route && line.includes(' - ') && !line.includes('KÃ¸rer') && !line.includes('Togart') && !line.includes('Hast')) {
                    const routeMatch = line.match(/([A-Za-zÃ¦Ã¸Ã¥Ã†Ã˜Ã…\.\s]+\s*-\s*[A-Za-zÃ¦Ã¸Ã¥Ã†Ã˜Ã…\.\s]+)/);
                    if (routeMatch) route = routeMatch[1].trim();
                }
            }

            // Look for KÃ¸rer (schedule) - format: "KK - PHM Daglig." or dates
            // The schedule info follows the route code pattern
            const korerMatch = combinedText.match(/KÃ¸rer:?\s*[A-Z]{2,3}\s*-\s*[A-Z]{2,3}\s+(.+?)(?=\s+Togart|$)/i);
            if (korerMatch) {
                schedule = korerMatch[1].trim();
                // Clean up - remove trailing route codes
                schedule = schedule.replace(/\s+[A-Z]{2,3}\s*-\s*[A-Z]{2,3}.*$/, '').trim();
            }

            // Look for Togart - format: "KK - PHM ET" - we want just "ET"
            const togartMatch = combinedText.match(/Togart:?\s*[A-Z]{2,3}\s*-\s*[A-Z]{2,3}\s+([A-Z]{2,3})/i);
            if (togartMatch) {
                togart = togartMatch[1].trim();
            }

            // Look for Hast km/t - format: "KK - PHM 180" - we want just "180"
            const hastMatch = combinedText.match(/Hast\s*km\s*\/?\s*t:?\s*[A-Z]{2,3}\s*-\s*[A-Z]{2,3}\s+(\d{2,3})/i);
            if (hastMatch) {
                hast = hastMatch[1] + ' km/t';
            }

            return { route, schedule, togart, hast };
        }

        function extractTimetableForGroup(trainNum, startLine) {
            const results = [];
            const seenStations = new Set();
            let endLine = startLine + 50;
            let timetableStart = startLine;

            // Find where the timetable starts (after "Ank" and "Afg" header)
            for (let i = startLine; i <= endLine && i < pdfLines.length; i++) {
                if (pdfLines[i] && pdfLines[i].includes('Ank') && pdfLines[i].includes('Afg')) {
                    timetableStart = i + 1;
                    break;
                }
            }

            let currentHour = '05';

            // Known station codes to strip from end of line (2-3 uppercase letters)
            const stationCodes = ['PHM', 'CPH', 'TÃ…T', 'TAT', 'Ã˜RE', 'ORE', 'KLV', 'BAN', 'KH', 'KN', 'KK', 'Ã–P', 'Ã˜P', 'SÃ…', 'SA', 'HÃ˜J', 'HOJ', 'VEJ'];

            for (let lineIndex = timetableStart; lineIndex <= endLine && lineIndex < pdfLines.length; lineIndex++) {
                const line = pdfLines[lineIndex];
                if (!line || line.trim().length < 3) continue;

                // Stop if we hit a new train header
                if (/Ã˜P\s*\d{3,4}/.test(line) && !line.includes('Ank')) break;
                if (line.includes('KÃ¸rer:') || line.includes('Togart:')) continue;
                if (line.includes('Ank') && line.includes('Afg')) continue;
                // Skip lines that are just headers or metadata
                if (line.includes('Hast km')) continue;

                let parts = line.trim().split(/\s+/);

                // Combine numbers/times with following Â½ (e.g., ['32', 'Â½'] -> ['32Â½'] or ['12:02', 'Â½'] -> ['12:02Â½'])
                const combinedParts = [];
                for (let i = 0; i < parts.length; i++) {
                    const isHalfNext = parts[i + 1] === 'Â½' || parts[i + 1] === '1/2';
                    const isNumber = /^\d{1,2}$/.test(parts[i]);
                    const isTime = /^\d{1,2}:\d{2}$/.test(parts[i]);
                    if (isHalfNext && (isNumber || isTime)) {
                        combinedParts.push(parts[i] + 'Â½');
                        i++; // Skip the Â½
                    } else {
                        combinedParts.push(parts[i]);
                    }
                }
                parts = combinedParts;

                // Remove station code from end if present (2-3 uppercase letters)
                let endIndex = parts.length;
                let stationCode = '';
                const lastPart = parts[parts.length - 1];
                if (/^[A-ZÃ†Ã˜Ã…]{2,3}$/.test(lastPart)) {
                    stationCode = lastPart;
                    endIndex = parts.length - 1;
                }

                // Work backwards to find times (last 1-2 elements that are times/dashes)
                let timeValues = [];
                let stationEndIndex = endIndex;

                for (let i = endIndex - 1; i >= 0 && timeValues.length < 2; i--) {
                    const part = parts[i];
                    const isFullTime = /^[0-2]?[0-9]:[0-5][0-9][Â½]?$/.test(part);
                    // Match 1-2 digit numbers optionally followed by Â½
                    const isMinuteOnly = /^[0-5]?[0-9][Â½]?$/.test(part);
                    const isDash = part === '-' || part === 'â€“' || part === 'â€”';
                    const isPass = part.toLowerCase() === 'pass' || part.toLowerCase() === 'p';

                    if (isFullTime || isMinuteOnly || isDash || isPass) {
                        stationEndIndex = i;
                        if (isFullTime) {
                            const cleaned = part.replace('Â½', '');
                            const [h, m] = cleaned.split(':');
                            currentHour = h.padStart(2, '0');
                            timeValues.unshift(`${currentHour}:${m.padStart(2, '0')}`);
                        } else if (isDash || isPass) {
                            timeValues.unshift('-');
                        } else if (isMinuteOnly) {
                            const mins = part.replace('Â½', '').padStart(2, '0');
                            timeValues.unshift(`${currentHour}:${mins}`);
                        }
                    } else {
                        // Not a time, stop looking
                        break;
                    }
                }

                // Everything before stationEndIndex is the station name
                const stationParts = parts.slice(0, stationEndIndex);

                if (stationParts.length > 0 && timeValues.length > 0) {
                    let station = stationParts.join(' ').trim();

                    // Clean up station name - keep dots for abbreviations like "Kbh." and Danish chars
                    station = station.replace(/[^\wÃ¦Ã¸Ã¥Ã†Ã˜Ã…Ã¶Ã–\s\-\.]/gi, '').replace(/\s+/g, ' ').trim();

                    // Also try to catch stations that might have been missed - check if station looks valid
                    const looksLikeStation = station.length > 1 && station.length < 40 &&
                        /^[A-ZÃ†Ã˜Ã…Ã–a-zÃ¦Ã¸Ã¥Ã¶]/.test(station) && // Starts with letter
                        !/^\d+$/.test(station); // Not just numbers

                    if (looksLikeStation && !seenStations.has(station.toLowerCase())) {
                        seenStations.add(station.toLowerCase());

                        let arrival = '-';
                        let departure = '-';

                        if (timeValues.length >= 2) {
                            arrival = timeValues[0];
                            departure = timeValues[1];
                        } else if (timeValues.length === 1) {
                            // For pass-through stations, use same time or dash
                            arrival = timeValues[0];
                            departure = timeValues[0];
                        }

                        results.push({
                            station,
                            arrival,
                            departure,
                            code: stationCode
                        });
                    }
                }
            }

            return results;
        }

        function showVariantSelector(variants, query) {
            let html = '<div class="variant-options">';

            variants.forEach((v, i) => {
                const routeDisplay = v.route || `${v.firstStation} â†’ ${v.lastStation}`;
                const isActive = activeVariantIndex === i;
                const isSaved = isTrainVariantSaved(query, i);
                html += `
                    <div class="variant-option ${isActive ? 'active' : ''}" data-index="${i}">
                        <div class="variant-left">
                            <div class="variant-number">${i + 1}</div>
                            <div class="variant-info">
                                <div class="variant-route"><strong>Tog ${query}</strong> Â· ${routeDisplay}</div>
                                <div class="variant-times">ðŸ“… ${v.schedule || `${v.firstTime} - ${v.lastTime}`}</div>
                            </div>
                        </div>
                        <div style="display:flex;align-items:center;gap:6px;">
                            <div class="variant-stops">${v.stopCount} stop â†’</div>
                            <button class="save-train-btn ${isSaved ? 'saved' : ''}" data-save-index="${i}" title="${isSaved ? 'Redan sparad' : 'Spara tÃ¥gnummer'}" ${isSaved ? 'disabled' : ''}>
                                ${isSaved ? 'âœ“' : '+'}
                            </button>
                        </div>
                    </div>`;
            });

            html += '</div>';
            variantSelector.innerHTML = html;

            // Add click handlers for save buttons
            variantSelector.querySelectorAll('.save-train-btn[data-save-index]').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.saveIndex);
                    const v = variants[idx];
                    const routeDisplay = v.route || `${v.firstStation} â†’ ${v.lastStation}`;
                    await saveTrain(query, idx, routeDisplay, v.firstTime || '', v);
                    // Update button state
                    btn.classList.add('saved');
                    btn.innerHTML = 'âœ“';
                    btn.disabled = true;
                });
            });

            variantSelector.querySelectorAll('.variant-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    const index = parseInt(opt.dataset.index);
                    if (activeVariantIndex === index) {
                        // Toggle off
                        closeTimetableOverlay();
                        activeVariantIndex = -1;
                        opt.classList.remove('active');
                    } else {
                        // Open this variant
                        activeVariantIndex = index;
                        // Update active state
                        variantSelector.querySelectorAll('.variant-option').forEach(o => o.classList.remove('active'));
                        opt.classList.add('active');
                        openTimetableOverlay(currentVariants[index], currentTrainQuery);
                    }
                });
            });
        }

        function openTimetableOverlay(variant, query) {
            activeTrainNumber = parseInt(query) || null; // Store the train number
            laReminderShown = false; // Reset reminder flag

            // Save view state for restoration on app restart
            setTimeout(() => saveViewState(), 100);

            // Find departure time from KÃ¸benhavn H
            activeKbhDeparture = null;
            const kbhStop = variant.stops.find(s =>
                s.station.toLowerCase().includes('kÃ¸benhavn h') ||
                s.station.toLowerCase().includes('kobenhavn h')
            );
            if (kbhStop && kbhStop.departure && kbhStop.departure !== '-') {
                activeKbhDeparture = kbhStop.departure;
            }

            // Find departure time from Ã˜sterport (for even train numbers)
            activeOsterportDeparture = null;
            activePeberholmDeparture = null;
            infoTrackerShown = false;
            if (activeTrainNumber && activeTrainNumber % 2 === 0) {
                const osterportStop = variant.stops.find(s =>
                    s.station.toLowerCase().includes('Ã¸sterport') ||
                    s.station.toLowerCase().includes('osterport') ||
                    s.station.toLowerCase().includes('Ã¶sterport')
                );
                if (osterportStop && osterportStop.departure && osterportStop.departure !== '-') {
                    activeOsterportDeparture = osterportStop.departure;
                }

                // Find departure time from Peberholm
                const peberholmStop = variant.stops.find(s =>
                    s.station.toLowerCase().includes('peberholm')
                );
                if (peberholmStop && peberholmStop.departure && peberholmStop.departure !== '-') {
                    activePeberholmDeparture = peberholmStop.departure;
                }
            }

            // Start checking for LA reminder
            startLaReminderCheck();

            // Start checking for Info tracker popup (1 min before Peberholm)
            startInfoTrackerCheck();

            // Start countdown for even train numbers
            startCountdown();

            document.getElementById('timetableTrain').textContent = `Ã˜P ${query}`;
            document.getElementById('timetableInfo').textContent = variant.route || '';

            let metaHtml = '';
            if (variant.schedule) metaHtml += `<span>KÃ¸rer: ${variant.schedule}</span>`;
            if (variant.togart) metaHtml += `<span>Togart: ${variant.togart}</span>`;
            if (variant.hast) metaHtml += `<span>Hast: ${variant.hast}</span>`;

            let tableHtml = '<div class="timetable">';
            // Header row
            tableHtml += `
                <div class="timetable-header-row">
                    <span>Ã˜P ${query}</span>
                    <span>Ank</span>
                    <span>Afg</span>
                    <span>X-tog</span>
                </div>`;
            // Data rows
            variant.stops.forEach(s => {
                // Format times to show only minutes if hour is same as previous
                const arrDisplay = s.arrival === '-' ? '-' : s.arrival;
                const depDisplay = s.departure === '-' ? '-' : s.departure;
                tableHtml += `
                    <div class="timetable-row">
                        <span class="station-name">${s.station}</span>
                        <span class="time-arr">${arrDisplay}</span>
                        <span class="time-dep">${depDisplay}</span>
                        <span class="station-code">${s.code || ''}</span>
                    </div>`;
            });
            tableHtml += '</div>';

            const content = document.getElementById('timetableContent');
            content.innerHTML = `${metaHtml ? `<div class="timetable-meta">${metaHtml}</div>` : ''}${tableHtml}`;

            document.getElementById('timetableOverlay').classList.add('active');
        }

        function closeTimetableOverlay() {
            document.getElementById('timetableOverlay').classList.remove('active');
            activeVariantIndex = -1;
            activeTrainNumber = null; // Clear active train number
            activeKbhDeparture = null;
            activeOsterportDeparture = null;
            activePeberholmDeparture = null;
            stopLaReminderCheck();
            stopCountdown();
            stopInfoTrackerCheck();
            // Remove active state from variants
            variantSelector.querySelectorAll('.variant-option').forEach(o => o.classList.remove('active'));
            // Update saved view state
            saveViewState();
        }

        function startLaReminderCheck() {
            stopLaReminderCheck(); // Clear any existing interval
            if (!activeKbhDeparture || !activeTrainNumber) return;

            laReminderInterval = setInterval(() => {
                if (laReminderShown || !activeKbhDeparture) return;

                const now = new Date();
                const [depHour, depMin] = activeKbhDeparture.split(':').map(Number);

                // Create departure time for today
                const depTime = new Date();
                depTime.setHours(depHour, depMin, 0, 0);

                // Calculate difference in seconds
                const diffSeconds = (depTime - now) / 1000;

                // If we're between 30 and 25 seconds before departure, show reminder
                if (diffSeconds <= 30 && diffSeconds > 25) {
                    laReminderShown = true;
                    showLaReminder();
                }
            }, 1000);
        }

        function stopLaReminderCheck() {
            if (laReminderInterval) {
                clearInterval(laReminderInterval);
                laReminderInterval = null;
            }
        }

        function showLaReminder() {
            if (!activeTrainNumber) return;

            // Even train number -> StrÃ¦kning 11, Odd -> StrÃ¦kning 10
            const isEven = activeTrainNumber % 2 === 0;
            const straekning = isEven ? '11' : '10';
            const straekningName = `StrÃ¦kning ${straekning}`;

            const modal = document.createElement('div');
            modal.className = 'la-reminder-modal';
            modal.innerHTML = `
                <div class="la-reminder-content">
                    <div class="la-reminder-text">
                        <strong>Tog ${activeTrainNumber}</strong> avgÃ¥r snart frÃ¥n KÃ¸benhavn H
                    </div>
                    <div class="la-reminder-question">Ã–ppna LA fÃ¶r ${straekningName}?</div>
                    <div class="la-reminder-buttons">
                        <button class="la-reminder-btn la-reminder-no" onclick="closeLaReminder(this)">Nej</button>
                        <button class="la-reminder-btn la-reminder-yes" onclick="openLaFromReminder('${straekning}', this)">Ja, Ã¶ppna</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Auto-close after 10 seconds
            setTimeout(() => {
                if (modal.parentNode) {
                    modal.remove();
                }
            }, 10000);
        }

        function closeLaReminder(btn) {
            const modal = btn.closest('.la-reminder-modal');
            if (modal) modal.remove();
        }

        function openLaFromReminder(routeId, btn) {
            closeLaReminder(btn);

            // Get today's date and find the LA file
            const today = getDateSwedish(0);
            const fileName = getFileName(routeId, today);
            const url = getFullUrl(fileName);

            if (isFileAvailable(fileName)) {
                openPdfOverlay(url, fileName);
            }
        }

        function testLaReminder() {
            // Use the active train number if available, otherwise use a test number
            if (!activeTrainNumber) {
                // No train open, show a message
                activeTrainNumber = 1010; // Default test with even number
            }
            laReminderShown = false;
            showLaReminder();
        }

        // ========================================
        // INFO TRACKER POPUP (1 min before Peberholm)
        // ========================================

        function startInfoTrackerCheck() {
            stopInfoTrackerCheck();
            if (!activePeberholmDeparture || !activeTrainNumber || activeTrainNumber % 2 !== 0) return;

            const [depHour, depMin] = activePeberholmDeparture.split(':').map(Number);

            infoTrackerInterval = setInterval(() => {
                if (infoTrackerShown) return;

                const now = new Date();
                const currentMinutes = now.getHours() * 60 + now.getMinutes();
                const peberholmMinutes = depHour * 60 + depMin;
                const diff = peberholmMinutes - currentMinutes;

                // Show popup 1 minute before Peberholm departure
                if (diff === 1 || (diff === 0 && now.getSeconds() < 30)) {
                    infoTrackerShown = true;
                    showInfoTrackerPopup();
                }
            }, 10000); // Check every 10 seconds
        }

        function stopInfoTrackerCheck() {
            if (infoTrackerInterval) {
                clearInterval(infoTrackerInterval);
                infoTrackerInterval = null;
            }
        }

        function showInfoTrackerPopup() {
            // Remove any existing popup
            const existing = document.querySelector('.info-tracker-modal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.className = 'info-tracker-modal';
            modal.innerHTML = `
                <div class="info-tracker-content">
                    <div class="info-tracker-title">ðŸ“ Peberholm om 1 minut</div>
                    <div class="info-tracker-text">Vill du Ã¶ppna Info tracker?</div>
                    <div class="info-tracker-buttons">
                        <button class="info-tracker-btn info-tracker-no" onclick="closeInfoTrackerPopup(this)">Nej</button>
                        <button class="info-tracker-btn info-tracker-yes" onclick="openInfoTracker(this)">Ja</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Auto-close after 30 seconds
            setTimeout(() => {
                if (document.body.contains(modal)) {
                    modal.remove();
                }
            }, 30000);
        }

        function closeInfoTrackerPopup(btn) {
            const modal = btn.closest('.info-tracker-modal');
            if (modal) modal.remove();
        }

        function openInfoTracker(btn) {
            closeInfoTrackerPopup(btn);
            // Open Info tracker app directly using Android launcher intent
            window.location.href = 'intent://#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;package=se.railit.app.infotracker.mpk;end';
        }

        // ========================================
        // COUNTDOWN TIMER (Ã˜sterport for even trains)
        // ========================================

        function startCountdown() {
            stopCountdown(); // Clear any existing interval

            const countdownContainer = document.getElementById('countdownContainer');
            const countdownTime = document.getElementById('countdownTime');

            // Only for even train numbers with Ã˜sterport departure
            if (!activeOsterportDeparture || !activeTrainNumber || activeTrainNumber % 2 !== 0) {
                countdownContainer.classList.add('hidden');
                return;
            }

            const [depHour, depMin] = activeOsterportDeparture.split(':').map(Number);

            function updateCountdown() {
                const now = new Date();
                const depTime = new Date();
                depTime.setHours(depHour, depMin, 0, 0);

                // Calculate difference in seconds
                const diffMs = depTime - now;
                const diffSeconds = Math.floor(diffMs / 1000);
                const diffMinutes = Math.floor(diffSeconds / 60);

                // Only show if within 10 minutes (600 seconds) and not passed
                if (diffSeconds <= 600 && diffSeconds > -60) {
                    countdownContainer.classList.remove('hidden');

                    if (diffSeconds <= 0) {
                        // Train has departed or departing now
                        countdownTime.textContent = 'NU!';
                        countdownContainer.classList.add('urgent');
                    } else {
                        const mins = Math.floor(diffSeconds / 60);
                        const secs = diffSeconds % 60;
                        countdownTime.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;

                        // Urgent styling under 2 minutes
                        if (diffSeconds <= 120) {
                            countdownContainer.classList.add('urgent');
                        } else {
                            countdownContainer.classList.remove('urgent');
                        }
                    }
                } else if (diffSeconds <= -60) {
                    // More than 1 minute past departure, hide
                    countdownContainer.classList.add('hidden');
                    stopCountdown();
                } else {
                    // More than 10 minutes away, hide
                    countdownContainer.classList.add('hidden');
                }
            }

            // Initial update
            updateCountdown();

            // Update every second
            countdownInterval = setInterval(updateCountdown, 1000);
        }

        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            const countdownContainer = document.getElementById('countdownContainer');
            if (countdownContainer) {
                countdownContainer.classList.add('hidden');
                countdownContainer.classList.remove('urgent');
            }
        }

        function hideCountdown() {
            stopCountdown();
            activeOsterportDeparture = null; // Prevent it from restarting
        }

        // ========================================
        // CLOCK
        // ========================================

        function updateClock() {
            const now = new Date();
            const options = {
                timeZone: 'Europe/Stockholm',
                weekday: 'short',
                day: 'numeric',
                month: 'short',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            };
            const formatted = now.toLocaleString('sv-SE', options);
            document.getElementById('headerClock').textContent = formatted;
        }

        // ========================================
        // INIT
        // ========================================

        async function cleanupOldFiles() {
            // Remove cached LA files older than 2 days
            const twoDaysAgo = new Date();
            twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
            twoDaysAgo.setHours(0, 0, 0, 0);

            let removedCount = 0;

            // Clean from IndexedDB
            const files = await getAllFromIDB('files');
            for (const file of files) {
                // Extract date from filename: La-10-2024-12-20-...
                const match = file.name.match(/La-\d+-(\d{4}-\d{2}-\d{2})/);
                if (match) {
                    const fileDate = new Date(match[1]);
                    if (fileDate < twoDaysAgo) {
                        await deleteFromIDB('files', file.name);
                        cachedFiles.delete(file.name);
                        removedCount++;
                    }
                }
            }

            // Clean from Cache API
            if ('caches' in window) {
                try {
                    const cache = await caches.open('dkapp-pdfs');
                    const keys = await cache.keys();
                    for (const request of keys) {
                        const url = request.url;
                        const match = url.match(/La-\d+-(\d{4}-\d{2}-\d{2})/);
                        if (match) {
                            const fileDate = new Date(match[1]);
                            if (fileDate < twoDaysAgo) {
                                await cache.delete(request);
                                removedCount++;
                            }
                        }
                    }
                } catch (e) {
                    console.log('Cache cleanup error:', e);
                }
            }

            if (removedCount > 0) {
                console.log(`Rensade ${removedCount} gamla filer`);
            }
        }

        async function initApp() {
            // Initialize IndexedDB first for offline support
            await initDB();

            // Clean up old cached files (older than 2 days)
            await cleanupOldFiles();

            updateClock();
            setInterval(updateClock, 1000);
            // Update saved trains highlighting every minute
            setInterval(renderSavedTrains, 60000);
            refreshLaDisplay();
            loadTrainPDF();
            loadSavedTrains();

            // Restore any open views from previous session
            restoreViewState();

            // Listen for online/offline changes
            window.addEventListener('online', () => {
                console.log('Tillbaka online');
                refreshLaDisplay();
            });
            window.addEventListener('offline', () => {
                console.log('Gick offline');
                const syncStatus = document.getElementById('syncStatus');
                syncStatus.textContent = 'ðŸ“´ Offline';
                syncStatus.classList.remove('synced');
            });
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closePdfOverlay();
                closeTimetableOverlay();
            }
        });

        // Fullscreen functionality
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        document.addEventListener('fullscreenchange', () => {
            const icon = document.getElementById('fullscreenIcon');
            if (document.fullscreenElement) {
                // Exit fullscreen icon
                icon.innerHTML = '<path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>';
            } else {
                // Enter fullscreen icon
                icon.innerHTML = '<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>';
            }
        });
    </script>
</body>
</html>
